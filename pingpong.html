<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Basic Pong</title>
  <style>
    body{
      margin:0;
      height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background:#111;
      color:#fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      user-select:none;
    }
    #wrap{
      text-align:center;
    }
    canvas{
      background:#000;
      border:2px solid #444;
      display:block;
      margin:0 auto;
    }
    .hint{
      margin-top:10px;
      font-size:14px;
      opacity:.8;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="800" height="450"></canvas>
    <div class="hint">
      Left: <b>W/S</b> &nbsp; | &nbsp; Right: <b>↑/↓</b> &nbsp; | &nbsp; <b>Space</b> serve/reset
    </div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    // Game constants (kept simple)
    const W = canvas.width;
    const H = canvas.height;

    const paddle = {
      w: 12,
      h: 90,
      speed: 420 // px/sec
    };

    const ballBaseSpeed = 340; // px/sec

    let left = { x: 20, y: (H - paddle.h) / 2, vy: 0, score: 0 };
    let right = { x: W - 20 - paddle.w, y: (H - paddle.h) / 2, vy: 0, score: 0 };
    let ball = { x: W/2, y: H/2, r: 8, vx: 0, vy: 0 };

    let keys = new Set();
    let lastTime = performance.now();
    let paused = true; // waits for Space to serve
    const winScore = 7;

    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

    function resetBall(servingToRight = true){
      ball.x = W / 2;
      ball.y = H / 2;

      // random slight angle so it’s not boring
      const angle = (Math.random() * 0.7 - 0.35); // -0.35..0.35 radians
      const dir = servingToRight ? 1 : -1;
      ball.vx = Math.cos(angle) * ballBaseSpeed * dir;
      ball.vy = Math.sin(angle) * ballBaseSpeed;
      paused = true;
    }

    function serve(){
      if (!paused) return;
      paused = false;
    }

    function resetMatch(){
      left.score = 0;
      right.score = 0;
      left.y = (H - paddle.h)/2;
      right.y = (H - paddle.h)/2;
      resetBall(Math.random() > 0.5);
    }

    function drawNet(){
      ctx.fillStyle = "#333";
      const dashH = 14;
      const gap = 10;
      for (let y = 0; y < H; y += dashH + gap){
        ctx.fillRect(W/2 - 2, y, 4, dashH);
      }
    }

    function draw(){
      // background
      ctx.clearRect(0, 0, W, H);

      // midline/net
      drawNet();

      // paddles
      ctx.fillStyle = "#fff";
      ctx.fillRect(left.x, left.y, paddle.w, paddle.h);
      ctx.fillRect(right.x, right.y, paddle.w, paddle.h);

      // ball
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
      ctx.fill();

      // score
      ctx.fillStyle = "#fff";
      ctx.font = "28px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(`${left.score}   :   ${right.score}`, W/2, 40);

      // messages
      ctx.font = "16px system-ui, sans-serif";
      if (left.score >= winScore || right.score >= winScore){
        const winner = left.score >= winScore ? "Left" : "Right";
        ctx.fillText(`${winner} wins! Press Space to restart`, W/2, H/2);
      } else if (paused){
        ctx.fillText("Press Space to serve", W/2, H/2);
      }
    }

    function collidePaddle(p, isLeft){
      // AABB collision between ball and paddle rect
      const bx = ball.x, by = ball.y, r = ball.r;
      const px = p.x, py = p.y, pw = paddle.w, ph = paddle.h;

      const hit =
        bx + r > px &&
        bx - r < px + pw &&
        by + r > py &&
        by - r < py + ph;

      if (!hit) return false;

      // Push ball out so it doesn't "stick"
      if (isLeft) ball.x = px + pw + r;
      else ball.x = px - r;

      // Reflect X velocity
      ball.vx *= -1;

      // Add "english" based on where it hits the paddle
      const center = py + ph/2;
      const offset = (by - center) / (ph/2); // -1..1
      ball.vy += offset * 220;

      // Very small speed-up so rallies don’t last forever
      ball.vx *= 1.03;
      ball.vy *= 1.03;

      return true;
    }

    function update(dt){
      // If match ended, wait for Space to restart
      if (left.score >= winScore || right.score >= winScore){
        paused = true;
        return;
      }

      // paddle input
      left.vy = 0;
      right.vy = 0;

      if (keys.has("KeyW")) left.vy = -paddle.speed;
      if (keys.has("KeyS")) left.vy = paddle.speed;
      if (keys.has("ArrowUp")) right.vy = -paddle.speed;
      if (keys.has("ArrowDown")) right.vy = paddle.speed;

      left.y = clamp(left.y + left.vy * dt, 0, H - paddle.h);
      right.y = clamp(right.y + right.vy * dt, 0, H - paddle.h);

      if (paused) return;

      // ball movement
      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;

      // top/bottom walls
      if (ball.y - ball.r < 0){
        ball.y = ball.r;
        ball.vy *= -1;
      }
      if (ball.y + ball.r > H){
        ball.y = H - ball.r;
        ball.vy *= -1;
      }

      // paddle collisions
      collidePaddle(left, true);
      collidePaddle(right, false);

      // scoring (ball exits left/right)
      if (ball.x + ball.r < 0){
        right.score++;
        resetBall(false); // serve toward left (loser) for variety
      }
      if (ball.x - ball.r > W){
        left.score++;
        resetBall(true);
      }
    }

    function loop(now){
      const dt = Math.min(0.033, (now - lastTime) / 1000); // cap dt
      lastTime = now;

      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    // Input
    window.addEventListener("keydown", (e) => {
      keys.add(e.code);

      if (e.code === "Space"){
        // If game ended, Space restarts match
        if (left.score >= winScore || right.score >= winScore){
          resetMatch();
          return;
        }
        // Otherwise serve if paused
        serve();
      }
    });

    window.addEventListener("keyup", (e) => keys.delete(e.code));

    // Start
    resetBall(true);
    requestAnimationFrame(loop);
  </script>
</body>
</html>
